<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:type" content="article"/>
<title>ardatasc.github.io</title>
<link rel="icon" href="../../favicon.png" type="image/x-icon">
<link rel="preconnect" href="https://fonts.googleapis.com/">
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link rel="preconnect" href="https://fonts.googleapis.com/">
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap.css" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com/">
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&amp;display=swap" rel="stylesheet">
<link rel="stylesheet" href="../../theme.min.7363202e6ba39c3b4caca8b218f6f6631256ed7a41cd2f8bf46550651b07cb31.css" integrity="">
</head>
<body>
  <div class="header">
  <div class="header-content">
  <div class="header-content-title">
  ardatasc
  </div>
  <div class="header-content-nav">
  <div class="header-content-nav-item">
  <a href="c.html">content</a>
  </div>
  <div class="header-content-nav-item">
  <a href="about.html">about</a>
  </div>
  </div>
  </div>
  </div>
<div class="content-container">
<div class="content"><h1 id="why-i-dont-care-about-my-linux-window-manager">Why I Don't Care About My Linux Window Manager</h1>
<p>Conversations around window managers can be a little contentious...but for some of us, it makes very little difference. I'm one of those humans. As much as I adore nerding out around some ultra-minimal window manager that requires you change settings by compiling its c code, at the end of the day I gain little benefit from any specific approach.</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
<iframe src="https://web.archive.org/web/20240228160126if_/https://www.youtube.com/embed/AK2UKUfsV3g" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
<p>That said, I do love and prefer Linux. The fact that we're afforded these choices around window managers is what draws many of us in initially. Your computer, whether running Ubuntu or Arch, can flip a switch to run a very capable, heavy-weight manager such as <a href="https://web.archive.org/web/20240228160126/https://kde.org/">KDE</a> or a manager with a binary size of ~1mb, such as <a href="https://web.archive.org/web/20240228160126/https://dwm.suckless.org/">dwm</a>. Before diving too deep into my day-to-day workflow, let's set some primer around window managers.</p>
<h2 id="window-managers">Window Managers</h2>
<p>Window managers come in two, primary, varieties. These include stacked and tiled. Tiled are commonly composed of several &quot;workspaces&quot;, which can be switched through and host one or many windows, tiled side-by-side. They (typically, by default) do not allow windows to stack or overlap. The following screenshot, from Wikipedia, demonstrates this for i3.</p>
<p><img src="https://web.archive.org/web/20240228160126im_/https://octetz.s3.us-east-2.amazonaws.com/why-i-dont-care-about-my-window-manager/i3.png" alt="https://octetz.s3.us-east-2.amazonaws.com/why-i-dont-care-about-my-window-manager/i3.png"></p>
<p>Stacked window managers, on the other hand, are what we conventionally think of. Especially those of us that have a history with OSX (mac) or Windows. These window managers give us floating windows that can overlap and be moved into any format on our screens. The following screenshot, from Wikipedia, demonstrates this for xfce.</p>
<p><img src="https://web.archive.org/web/20240228160126im_/https://octetz.s3.us-east-2.amazonaws.com/why-i-dont-care-about-my-window-manager/xfce.png" alt="https://octetz.s3.us-east-2.amazonaws.com/why-i-dont-care-about-my-window-manager/xfce.png"></p>
<p>From my experience, many have associated the move to tiling managers as a more hardcore approach to interacting with Linux. Or at least one we associate with focus, minimalism, and/or getting things done. Over the years, some using i3 and others using dwm, I have found my productivity remain relatively static. I did have some super cool layouts that I loved looking at. However, I am a habitual over-optimizer. This trait sends me down constant rabbit holes of thinking through what workspace I should assign to which tasks, how I should be setting up a tiling layout for optimal focus, and many more considerations. Eventually I realized this constant customization was causing me more loss in focus than the gain I'd hoped to have leaving stacked managers behind.</p>
<p>In short, this was a me problem, not a tiling window manager problem. Knowing myself better now, I have switched back to stacked managers, with optimizations and automation focused around my key priorities.</p>
<h2 id="priorities">Priorities</h2>
<p>My priorities around workflow are fairly straight forward. Given I have the attention span of a small squirrel, my key priorities are:</p>
<ol>
<li>Switch between key applications quickly</li>
<li>Switch between key applications with minimal context-switching</li>
</ol>
<p>So switching between applications, this isn't too hard in any window manager, is it? Sure, it is not. However minimizing the thought required to jump from a to b is huge for my work. For example, at the most intense end of the spectrum, clicking around and moving windows to find firefox is less than ideal. Even using flows like alt+tab or a launcher requires me to think about where the thing is or how to find/focus it. Additionally, the applications I care about and need to switch between are fairly minimal in quantity. There are maybe 7 total with 4 key ones I constantly toggle. These are:</p>
<ul>
<li>Web Browser (firefox)</li>
<li>Terminal (st)</li>
<li>IDE (intellij)</li>
<li>File browser (nemo)</li>
</ul>
<p>For me, the question is, with a key or two, can I bring up the application I need to get the task done no matter where it preexisted. Additionally, if the app isn't running, can I transparently launch it without being concerned about another shortcut or workflow? This is where my most important trick comes in, a script named <code>lof</code> (launch or focus).</p>
<h2 id="launch-or-focus-lof">Launch or Focus (lof)</h2>
<p><code>lof</code> is a simple script that does exactly what the name implies. If the app isn't running, it launches it. If the app is, it focuses it. <code>lof</code> is not a unique solution. For example there is <a href="https://web.archive.org/web/20240228160126/https://github.com/mkropat/jumpapp">jumpapp</a>, which is a far more capable tool than <code>lof</code>. I have chosen to write <code>lof</code> because it is less than 20 lines of shell script (when comments are removed), easy to understand, and handles 97% of my use cases.</p>
<p><code>lof</code> can be found in my <a href="https://web.archive.org/web/20240228160126/https://github.com/octetz/linux-desktop/blob/master/s/lof">octetz/linux-desktop repository</a>. I have <a href="https://web.archive.org/web/20240228160126/https://octetz.com/docs/2020/2020-02-23-linux-desktop-configuration/">another blog</a> post on how I use this repo, if you're interested. At the time of this writing, the script looks something like this.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/sh
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># lof: launch or focus</span>
</span></span><span class="line"><span class="cl"><span class="c1"># this script checks whether an app is running and</span>
</span></span><span class="line"><span class="cl"><span class="c1"># if running, focuses the window</span>
</span></span><span class="line"><span class="cl"><span class="c1"># if not running, launches the app</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># this script is likely called from another command or script</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># usage: lof [arg]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [arg]: provide the full path, arguments, and flags representing the process</span>
</span></span><span class="line"><span class="cl"><span class="c1"># The value of arg will be looked up literally in the process list by wrapping [arg] in ^ (start) and $ (end)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># for example, to ensure the correct firefox window is launched, lof would be used as follows:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># lof /usr/lib/firefox/firefox</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># for web-based apps, nodejs-natifier can be used to generate a desktop binary</span>
</span></span><span class="line"><span class="cl"><span class="c1"># https://aur.archlinux.org/packages/nodejs-nativefier</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># this script assumes the app exists and wmctrl is installed</span>
</span></span><span class="line"><span class="cl"><span class="c1"># checks do not occur to ensure optimal performance</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">APP_NAME</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># find pid for app process</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -f includes the entire process details, including arguments and flags</span>
</span></span><span class="line"><span class="cl"><span class="nv">APP_PID</span><span class="o">=</span><span class="s2">&#34;</span><span class="k">$(</span>pgrep -f <span class="s2">&#34;^</span><span class="si">${</span><span class="nv">APP_NAME</span><span class="si">}</span>$<span class="s2">&#34;</span><span class="k">)</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># if app is not running, start it</span>
</span></span><span class="line"><span class="cl"><span class="c1"># if app is running, focus it</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$APP_PID</span><span class="s2">&#34;</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">then</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># launch app</span>
</span></span><span class="line"><span class="cl">  <span class="nv">$APP_NAME</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># using the pid, find the window id, then focus it</span>
</span></span><span class="line"><span class="cl">  <span class="nv">wid</span><span class="o">=</span><span class="k">$(</span>wmctrl -lp <span class="p">|</span> grep <span class="s2">&#34;</span><span class="nv">$APP_PID</span><span class="s2">&#34;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $1}&#39;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># -R moves the window to the current desktop AND brings it to focus</span>
</span></span><span class="line"><span class="cl">  wmctrl -iR <span class="s2">&#34;</span><span class="nv">$wid</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span></code></pre></div><p><code>lof</code>'s goal is to determine if an app is running and if it's not, launch it. If it is running, it stores the process id and correlates that to the window id. Once the window id is found, it focuses the window, using a tool called <a href="https://web.archive.org/web/20240228160126/https://en.wikipedia.org/wiki/Wmctrl">wmctrl</a>. For example, my usage of <code>lof</code> for firefox is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">lof /usr/lib/firefox/firefox
</span></span></code></pre></div><p><code>lof</code> expects to resolve the <strong>exact</strong> command when it runs <code>pgrep</code>, this enables <code>lof</code> to be very specific around what window it looks up. If you're interested in the gory details of how these pieces fit together, keep reading this section. Otherwise, you should skip to the next section.</p>
<p>To understand <code>lof</code>, it is important to understand how window ids and process ids are related. Technically, we can look up windows by their titles, however, many applications re-title their window based on the context of where the user is in the app. Thus, correlating process id to window id is preferable. Assuming firefox is running, you can lookup its window id with <code>wmctrl</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wmctrl -lp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0x01800003 -1 <span class="m">899</span>    taco xfce4-panel
</span></span><span class="line"><span class="cl">0x01000028 -1 <span class="m">945</span>    taco Desktop
</span></span><span class="line"><span class="cl">0x02e00006  <span class="m">0</span> <span class="m">1139</span>   taco tmux
</span></span><span class="line"><span class="cl">0x0300004d  <span class="m">0</span> <span class="m">2804</span>   taco linux-desktop – lof
</span></span><span class="line"><span class="cl">0x03200003  <span class="m">0</span> <span class="m">5276</span>   taco Arch Linux - Mozilla Firefox
</span></span><span class="line"><span class="cl">0x06200006  <span class="m">0</span> <span class="m">7115</span>   taco VLC media player
</span></span></code></pre></div><p>In the above desktop, <em>Arch Linux - Mozilla Firefox</em> is clearly the firefox window. The process id is <code>5276</code> and the window id is <code>0x03200003</code>. Since <code>lof</code> resolves based on the process's command, we should look that up using the process id.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ps <span class="m">5276</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PID TTY      STAT   TIME COMMAND
</span></span><span class="line"><span class="cl"><span class="m">5276</span> pts/2    Sl    13:49 /usr/lib/firefox/firefox
</span></span></code></pre></div><p>And just like that, we know that <code>/usr/lib/firefox/firefox</code> is the correct argument to send to <code>lof</code>. When <code>lof /usr/lib/firefox/firefox</code> is run, <code>pgrep</code> is used to resolve a process with that <strong>exact</strong> command. If <code>pgrep</code> returns no result, <code>lof</code> executes the command it was fed as an argument. If <code>pgrep</code> did find a result, it can use the process id to run the above <code>wmctrl -lp</code> command and resolve the window id via <code>grep</code> and <code>awk</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wmctrl -lp <span class="p">|</span> grep <span class="m">5276</span> <span class="p">|</span> awk <span class="s1">&#39;{print $1}&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">0x03200003
</span></span></code></pre></div><p>It then uses <code>wmctrl -iR</code> to focus the firefox window.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wmctrl -iR 0x03200003
</span></span></code></pre></div><p>And that end-to-end is <code>lof</code>! There are times where some apps, such as those requiring JRE, need more love than <code>lof</code> can handle. In those cases, rather than making <code>lof</code> smarter, I chose to write a slightly modified script. You can find an example with my <a href="https://web.archive.org/web/20240228160126/https://github.com/octetz/linux-desktop/blob/master/s/lof_intellij">lof_intellij</a> script in GitHub.</p>
<h2 id="shortcuts">Shortcuts</h2>
<p>The glue that holds this all together is the shortcuts or key bindings. For key bindings, I use <a href="https://web.archive.org/web/20240228160126/https://wiki.archlinux.org/index.php/Xbindkeys">xbindkeys</a>. The reason I prefer it over other tools, is its generic approach to capturing mouse or keyboard events. Captured events can execute scripts in <strong>any window manager</strong>. This means that when I randomly decide to switch back to dwm, all my keys bindings come with me.</p>
<p>xbindkeys, assuming it is installed, can be added to your <code>~/.xinitrc</code> file to launch when you start your window manager. An example of mine is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">exec</span> xrdb ~/.Xresources <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl">xset r rate <span class="m">150</span> <span class="m">60</span> <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># only required when wm does not have compositor</span>
</span></span><span class="line"><span class="cl"><span class="c1"># exec picom &amp;</span>
</span></span><span class="line"><span class="cl">feh --bg-scale ~/photos/wallpapers/current.jpg <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl">xbindkeys -p <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># options are dwm, i3, and startxfce4</span>
</span></span><span class="line"><span class="cl"><span class="nb">exec</span> startxfce4
</span></span></code></pre></div><p>The <code>-p</code> flag tells <code>xbindkeys</code> to poll the rc (configuration) file for changes. The last step is to setup this rc file to include the <code>lof</code> commands. The rc file is, by default, located at <code>~/.xbindkeysrc</code>. On my machine, a some of the configuration look as follows.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># launch demu</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;dmenu_run -fn Hack-16:normal -l 5&#34;</span>
</span></span><span class="line"><span class="cl">    m:0x40 + c:65
</span></span><span class="line"><span class="cl">    Mod4 + space
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># launch browser</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;lof /usr/lib/firefox/firefox&#34;</span>
</span></span><span class="line"><span class="cl">    m:0x40 + c:45
</span></span><span class="line"><span class="cl">    Mod4 + k
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># launch or focus terminal</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;lof st\ \-e\ tmux&#34;</span>
</span></span><span class="line"><span class="cl">    m:0x40 + c:44
</span></span><span class="line"><span class="cl">    Mod4 + j
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># launch or focus nemo</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;lof nemo&#34;</span>
</span></span><span class="line"><span class="cl">    m:0x40 + c:40
</span></span><span class="line"><span class="cl">    Mod4 + d
</span></span></code></pre></div><p>You can see the many uses of <code>lof</code>. The quoted text is the script to be run when an event is detected for the key codes below it. <code>xbindkeys</code> offers a simple way to figure out these key strokes. You run <code>xbindkeys -k</code> and hit the key you want to resolve. For example, this is the result of <code>mod</code> (window key) + <code>e</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">xbindkeys -k
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Press combination of keys or/and click under the window.
</span></span><span class="line"><span class="cl">You can use one of the two lines after <span class="s2">&#34;NoCommand&#34;</span>
</span></span><span class="line"><span class="cl">in <span class="nv">$HOME</span>/.xbindkeysrc to <span class="nb">bind</span> a key.
</span></span><span class="line"><span class="cl"><span class="s2">&#34;(Scheme function)&#34;</span>
</span></span><span class="line"><span class="cl">    m:0x4 + c:26
</span></span><span class="line"><span class="cl">    Control + e
</span></span></code></pre></div><p>Now, assume you want to use that as a keyboard shortcut for the GUI app <code>blueman-manager</code> (a bluetooth utility). With the app running, you lookup the command.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ps aux <span class="p">|</span> grep -i blueman-manager
</span></span><span class="line"><span class="cl">josh       <span class="m">11874</span>  2.1  0.1 <span class="m">625088</span> <span class="m">51320</span> tty1     Sl   16:54   0:00 /usr/bin/python /usr/bin/blueman-manager
</span></span></code></pre></div><p>Now you can see the command is <code>/usr/bin/python /usr/bin/blueman-manager</code>. Due to the space, you must delimit it so it is treated as a space character and <strong>not</strong> a second argument passed to <code>lof</code>. Taking the information from the preceding examples, you can add the following to <code>~/.xbindkeysrc</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># launch blueman-manager</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;lof /usr/bin/python\ /usr/bin/blueman-manager&#34;</span>
</span></span><span class="line"><span class="cl">    m:0x40 + c:26
</span></span><span class="line"><span class="cl">    Mod4 + e
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># -- remainder of config redacted --</span>
</span></span></code></pre></div><p>Now <code>mod4</code>+<code>e</code> will launch or focus <code>blueman-manager</code>.</p>
<h2 id="summary">Summary</h2>
<p>In short, over years of using many different window managers with different philosophies, I've found that the idea of easily triggering the app I need to get to is the real value add for any desktop experience. This is true for me and, at a minimum, hopefully this provided interesting perspective for your future Linux endeavors!josh @ taco (/tmp) []</p>
</div>
<div class="content-toc">
<h3>Contents</h3>
<nav id="TableOfContents">
<ul>
<li><a href="index.html#window-managers">Window Managers</a></li>
<li><a href="index.html#priorities">Priorities</a></li>
<li><a href="index.html#launch-or-focus-lof">Launch or Focus (lof)</a></li>
<li><a href="index.html#shortcuts">Shortcuts</a></li>
<li><a href="index.html#summary">Summary</a></li>
</ul>
</nav>
</div>
</div>
</body>
</html>
<!--
     FILE ARCHIVED ON 16:01:26 Feb 28, 2024 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 03:18:00 Sep 10, 2024.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.423
  exclusion.robots: 0.016
  exclusion.robots.policy: 0.008
  esindex: 0.009
  cdx.remote: 10.821
  LoadShardBlock: 213.65 (3)
  PetaboxLoader3.datanode: 99.461 (4)
  PetaboxLoader3.resolve: 303.36 (2)
  load_resource: 214.522
-->
